* Server management

We want to run emacs in a server to increase startup speed, and to keep buffers alive across emacs windows. 
To better configure a emacs server, we create a reload-config lisp function that reloads the config file.
We need to be able to stop the server for a proper reset. This is smart if emacs starts acting out or breaks but you are still able to access new buffers.

#+begin_src emacs-lisp
(load "server")
(unless (server-running-p) (server-start))

;; Server & Config Management
(defun th/server-stop ()
  "Save buffers, Quit, and Shutdown (kill) server"
  (interactive)
  (save-some-buffers)
  (kill-emacs)
  )

(defun th/reload-config ()
  "Reload config"
  (interactive)
  ;;(org-babel-load-file (concat config-root "config.org"))
  (org-babel-load-file (expand-file-name "config.org" user-emacs-directory))
  )
#+end_src

* Startup Basics

We need to change some basic functionality and looks of emacs to modernize it.
this includes disabling distracting features like the tool bar and menu stuff.
Furthermore, the startup-screen can be annoying so we just boot into a blank scratch buffer instead.

#+begin_src emacs-lisp
;; Disable bars and other clutter
(menu-bar-mode -1)
(scroll-bar-mode -1)
(tool-bar-mode -1) 
(hl-line-mode)
(setq inhibit-startup-screen t)

;; Always follow symlinks for git sources (like this file!)
(setq vc-follow-symlinks t)

;; Life is too short for long questions
(defalias 'yes-or-no-p 'y-or-n-p)

;; Set font size
(set-face-attribute 'mode-line nil  :height 110)
(set-face-attribute 'default nil :height 110)

;; Enable line numbers globally
(global-linum-mode t)
;; auto close bracket insertion. New in emacs 24
(electric-pair-mode 1)
;; Enable text wrap by default
(add-hook 'text-mode-hook 'visual-line-mode)
;; Move backup files to backup directory
(setq backup-directory-alist '(("." . "~/.emacs.d/backups/")))
;; Default tab sizes
(setq-default tab-width 4)
;; change prompt from yes or no, to y or n
(setq use-short-answers t)
#+end_src

A useful feature is to be able to rename files that exists in open buffers without having them be dublicated.

#+begin_src emacs-lisp
(defun th/rename-current-buffer-file ()
  "Renames current buffer and the buffer's file."
  (interactive)
  (let* ((name (buffer-name))
        (filename (buffer-file-name))
        (basename (file-name-nondirectory filename)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " (file-name-directory filename) basename nil basename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))
#+end_src

Another useful feature is to use emacs as our terminal manager, since we run emacs as a server.
Here we create indexed terminals instead of having only one terminal active and having to rename it
to get more.
#+begin_src emacs-lisp
(defvar th/term-counter 0)
(defun th/term ()
  "Create a indexed terminal"
  (interactive)
  (setq th/term-counter (+ th/term-counter 1))
  (setq title (concat "Terminal-" (number-to-string th/term-counter)))
  (setq buf-title (concat "*" title "*"))
  (message buf-title)
  (set-buffer (make-term title "/bin/bash"))
  (term-mode)
  (term-char-mode)
  (switch-to-buffer buf-title)
)
#+end_src

It is also intresting to track emacs startup time, this can be added as a hook.
_note that this does not work for the server_, but is a useful debugging, performance tracker.

#+begin_src emacs-lisp
;; Count startup time of emacs
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "Emacs was ready in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))
#+end_src

* Evil Config

Emacs bindings are a pain.
But behold, lets bastardize our creation with proper editing herecy!
We install evil vim as our default editing mode.

#+begin_src emacs-lisp
;; Better undo compatability
(use-package undo-fu)
;; Proper editing
(use-package evil
  ;; tweak evil's configuration before loading it
  :init      
  ;; This is optional since it's already set to t by default.
  (setq evil-want-integration t) 
  (setq evil-want-keybinding nil)
  (setq evil-vsplit-window-right t)
  (setq evil-split-window-below t)
  :config
  (evil-mode)
  (setq evil-search-module 'evil-search))

;; Editing but for lots of modes
(use-package evil-collection
  :after 'evil
  :config
  (setq evil-collection-mode-list '(dashboard dired ibuffer))
  (evil-collection-init))
(evil-mode)
(evil-collection-init)

;; to work properly with evil-collection
(setq evil-want-keybinding nil)
;; no vim insert bindings
(setq evil-undo-system 'undo-fu)
#+end_src

Vim needs a leader key, this makes bindings easier to reconfigure if a new leader key is defined in the future. Evil vim does not know this notion, so we define it ourselves. 

But even vim lacks some movement features that we would like... So we setup some lazy movement mechanics that is basically a copy of how i did things in vim.

#+begin_src emacs-lisp
;; Escape a buffer
(define-key global-map (kbd "<escape>") #'keyboard-escape-quit)

;; Evil Leader Key
(setq LEADER "<SPC>")
;; TODO: Space is bound in some window modes, find a way to disable it!

;; Vim window movement
(define-key evil-normal-state-map (kbd (concat LEADER "h")) #'evil-window-left)
(define-key evil-normal-state-map (kbd (concat LEADER "j")) #'evil-window-down)
(define-key evil-normal-state-map (kbd (concat LEADER "k")) #'evil-window-up)
(define-key evil-normal-state-map (kbd (concat LEADER "l")) #'evil-window-right)

;; Window Creation Deletion
(define-key evil-normal-state-map (kbd (concat LEADER "sb")) #'split-window-below)
(define-key evil-normal-state-map (kbd (concat LEADER "sr")) #'split-window-right)
(define-key evil-normal-state-map (kbd (concat LEADER "sq")) #'delete-window)

;; Buffer Management
(define-key evil-normal-state-map (kbd (concat LEADER "bs")) 'switch-to-buffer)
(define-key evil-normal-state-map (kbd (concat LEADER "bm")) 'ibuffer)
(define-key evil-normal-state-map (kbd (concat LEADER "bn")) 'next-buffer)
(define-key evil-normal-state-map (kbd (concat LEADER "bp")) 'previous-buffer)

;;(require 'comint)
;;(define-key evil-normal-state-map (kbd (concat LEADER "f")) 'comint-dynamic-complete-filename)

;; Quick file scrolling
(define-key evil-normal-state-map (kbd "J") "10j")
(define-key evil-normal-state-map (kbd "K") "10k")
#+end_src

* Note Taking with Org

We need a way to manage files, documents and notes on a lot of stuff.
This could be seperate from emacs but lets try experimenting with org mode, a zettlekasten method of keeping a notebook full of notes that may, or may not have correlations, and lets you easily navigate notes. 

Org is already loaded in init.el.

#+begin_src emacs-lisp
(setq org-src-preserve-indentation t)
(use-package org-roam
  :ensure t
  :init
  (setq org-roam-v2-ack t)
  :custom
  (org-roam-directory "~/Dropbox/Org-Roam")
  :config
  (org-roam-setup)
  )
#+end_src

Org mode has some bad header size choises we would like to disable, ensuring optimal
screen usage by not having huge headers.
#+begin_src emacs-lisp
(dolist (face '(org-level-1 org-level-2 org-level-3 org-level-4 org-level-5))
  (set-face-attribute face nil :weight 'semi-bold :height 1.0))
#+end_src

We are evil vim users, so we need to set our own org-roam navigation bindings, i have decided to use w as the preface for org roam bindings.
We also create a smarter method of creating notes, the default behaviour forces you to use node-insert twice, once for creating a note, and once for creating a link to a note. We make a immediate function to ease this overhead.
#+begin_src emacs-lisp
;; Insert Org-Roam node link quickly without opening a buffer
(defun th/org-roam-node-insert-immediate (arg &rest args)
  (interactive "P")
  (let ((args (cons arg args))
        (org-roam-capture-templates (list (append (car org-roam-capture-templates)
                                                  '(:immediate-finish t)))))
    (apply #'org-roam-node-insert args)))

(define-key evil-normal-state-map (kbd (concat LEADER "wI")) 'org-roam-node-insert)
(define-key evil-normal-state-map (kbd (concat LEADER "wi")) 'th/org-roam-node-insert-immediate)
(define-key evil-normal-state-map (kbd (concat LEADER "wf")) 'org-roam-node-find)
;; Shows backlinks for current buffer
(define-key evil-normal-state-map (kbd (concat LEADER "wb")) 'org-roam-buffer-toggle)
;; insert links to stuff that is not or roam files
(define-key evil-normal-state-map (kbd (concat LEADER "wl")) 'org-insert-link)
#+end_src

Lets also manage org roam's image capabilities with org-inline-pdf, and change viewing options.
#+begin_src emacs-lisp
;; Max width for org images
(setq org-image-actual-width  900)
;; Start with images open
(setq org-startup-with-inline-images t)
;; Org pdf viewing
(use-package org-inline-pdf)
(add-hook 'org-mode-hook #'org-inline-pdf-mode)
#+end_src

** visualization

It would be nice to get an overview of a zettlekasten notebook. Once that shows connecitons througout the notes.
This can be done in a awesome browser-based note navigator!

#+begin_src emacs-lisp
(use-package org-roam-ui)
(define-key evil-normal-state-map (kbd (concat LEADER "wg")) 'org-roam-ui-open)
#+end_src

* Standard Programs for Filetypes

What about opening files?
We would like to specify what programs opens what filetypes by default.

#+begin_src emacs-lisp
(use-package openwith)
(setq openwith-associations
      (list
       (list (openwith-make-extension-regexp
              '("mpg" "mpeg" "mp3" "mp4" "m4v"
                "avi" "wmv" "wav" "mov" "flv"
                "ogm" "ogg" "mkv" "webm"))
             "ffplay"
             '(file))
       (list (openwith-make-extension-regexp
              '("pdf"))
             "zathura"
             '(file))))

(openwith-mode 1)

;; Supress large file warnings
(setq large-file-warning-threshold nil)
#+end_src

Org mode behaves like a problem child though, and needs extra treatment for its file opening system.

#+begin_src emacs-lisp
;; org mode changes
  (setq org-file-apps
    '(("\\.docx\\'" . default)
      ("\\.mm\\'" . default)
      ("\\.x?html?\\'" . default)
      ("\\.pdf\\'" . "zathura \"%s\"")
      (auto-mode . emacs)))
#+end_src

* Development Environment

We need some programming help in our emacs config.
This is something we can do with a LSP (languange server protocol) using lsp-mode.
We need to install a lot of packages for this..

#+begin_src emacs-lisp
(setq package-selected-packages '(lsp-mode yasnippet lsp-treemacs helm-lsp
    projectile hydra flycheck company avy which-key helm-xref dap-mode))

(when (cl-find-if-not #'package-installed-p package-selected-packages)
  (package-refresh-contents)
  (mapc #'package-install package-selected-packages))

#+end_src

We also make use of helm, a better file searcher that suits our needs.

#+begin_src emacs-lisp
;; sample `helm' configuration use https://github.com/emacs-helm/helm/ for details
(helm-mode)
(require 'helm-xref)
(define-key global-map [remap find-file] #'helm-find-files)
(define-key global-map [remap execute-extended-command] #'helm-M-x)
(define-key global-map [remap switch-to-buffer] #'helm-mini)

;; Tab completion instead of enter completion(define-key helm-map (kbd "TAB") #'helm-execute-persistent-action)
(define-key helm-map (kbd "TAB") #'helm-execute-persistent-action)
(define-key helm-map (kbd "<tab>") #'helm-execute-persistent-action)
(define-key helm-map (kbd "C-z") #'helm-select-action)

(which-key-mode)
#+end_src

** C-Cpp

https://emacs-lsp.github.io/lsp-mode/tutorials/CPP-guide/
https://www.reddit.com/r/emacs/comments/sx1fkg/cc_development_in_emacs/

#+begin_src emacs-lisp
(add-hook 'c-mode-hook 'lsp)
(add-hook 'c++-mode-hook 'lsp)

(setq c-default-style "linux")
(setq-default c-basic-offset 4
              tab-width 4
              indent-tabs-mode t)

(setq gc-cons-threshold (* 100 1024 1024)
      read-process-output-max (* 1024 1024)
      treemacs-space-between-root-nodes nil
      company-idle-delay 0.0
      company-minimum-prefix-length 1
      lsp-idle-delay 0.1)  ;; clangd is fast

(with-eval-after-load 'lsp-mode
  (add-hook 'lsp-mode-hook #'lsp-enable-which-key-integration)
  (require 'dap-cpptools)
  (yas-global-mode))
#+end_src

** Latex

Spelling and grammer plugin:
#+begin_src emacs-lisp
(use-package flyspell-correct-helm)
(dolist (hook '(tex-mode-hook))
    (add-hook hook (lambda () (flyspell-mode 1))))

(add-hook 'tex-mode-hook 'flyspell-buffer)
#+end_src

TODO: latex stuff:
[[https://ejenner.com/post/latex-emacs/][Emacs as Latex editor]]

We want a lot of cool keybindings for our latex editing chores that are intuitive and fast to use.
These are ported over from an old neovim config, but works due to emacs being in evil mode.

TODO: Implement these!
https://www.youtube.com/watch?v=Mphdtdv2_xs

** LISP

We need a cool lisp environment now that we are using emacs. Sly is a modern alternative to a interactive repl environment.
We can use company to have quick intellisense in our enviroments.

[[https://joaotavora.github.io/sly/#Basic-setup][SLY documentation and setup help]]

#+begin_src emacs-lisp
;; Sly is a interactive lisp program
(use-package sly)
(setq inferior-lisp-program "sbcl")

; Provide company autocomplete in a couple of useful environments
(add-hook 'lisp-mode-hook 'company-mode)
(add-hook 'tex-mode-hook 'company-mode)
(add-hook 'org-mode-hook 'company-mode)

#+end_src

** Python

#+begin_src emacs-lisp
;; Python lsp tutorial:
;; https://taingram.org/blog/emacs-lsp-ide.html
(add-hook 'python-mode-hook 'lsp)

(setq gc-cons-threshold (* 100 1024 1024)
      read-process-output-max (* 1024 1024)
      treemacs-space-between-root-nodes nil
      company-idle-delay 0.0
      company-minimum-prefix-length 1
      lsp-idle-delay 0.1)  ;; clangd is fast

(with-eval-after-load 'lsp-mode
  (add-hook 'lsp-mode-hook #'lsp-enable-which-key-integration)
  (require 'dap-cpptools)
  (yas-global-mode))
#+end_src

* Themes

We install some themes for emacs.
We set monokai as default because of its clarity and warm usage of pastel colors.

#+begin_src emacs-lisp
(use-package better-defaults)

(use-package material-theme)
(use-package monokai-theme)

;; set a default theme
(load-theme 'monokai t)
#+end_src

* Starter Page

We can define a custom start page for our emacs, so when we create a empty buffer, we are sent to our start page instead.

#+begin_src emacs-lisp

(setq initial-buffer-choice "~/.emacs.d/starter.org")

(define-minor-mode start-mode
  "Provide functions for custom start page."
  :lighter " start"
  :keymap (let ((map (make-sparse-keymap)))
          ;;(define-key map (kbd "M-z") 'eshell)
            (evil-define-key 'normal start-mode-map
              (kbd "1") '(lambda () (interactive) (find-file "~/.emacs.d/config.org"))
              (kbd "2") '(lambda () (interactive) (find-file "~/.emacs.d/init.el"))
              (kbd "3") '(lambda () (interactive) (find-file "~/.bashrc"))
              ;;(kbd "4") '(lambda () (interactive) (find-file "~/Masters-Thesis/report/main.tex"))
              )
          map))

(add-hook 'start-mode-hook 'read-only-mode)
(provide 'start-mode)

#+end_src
